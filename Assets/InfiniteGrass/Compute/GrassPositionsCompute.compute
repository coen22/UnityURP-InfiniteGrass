#pragma kernel CSMain

float _Spacing;
float _DrawDistance;
float _TextureUpdateThreshold;
float _FullDensityDistance;
float _DensityFalloffExponent;

int2 _GridStartIndex;
int2 _GridSize;
float3 _CameraPosition;
float2 _CenterPos;
float3 _BoundsMin;
float3 _BoundsMax;

float4x4 _VPMatrix;

SamplerState linearClampSampler;

float2 _HiZTextureSize;
Texture2D<float4> _HiZMap;
SamplerState sampler_HiZMap;

//Generated and passedby the Custom Renderer Feature
Texture2D<float2> _GrassHeightMapRT;
Texture2D<float> _GrassMaskMapRT;
//--------------------------------------------------

AppendStructuredBuffer<float4> _GrassPositions;

uint murmurHash3(int input) {
	uint h = abs(input);
	h ^= h >> 16;
	h *= 0x85ebca6b;
	h ^= h >> 13;
	h *= 0xc2b2ae3d;
	h ^= h >> 16;
	return h;
}

float random(int index)
{
	return murmurHash3(index) / 4294967295.0;
}

float Remap(float In, float2 InMinMax, float2 OutMinMax)
{
    return OutMinMax.x + (In - InMinMax.x) * (OutMinMax.y - OutMinMax.x) / (InMinMax.y - InMinMax.x);
}

uint IsVisibleAfterFrustumCulling(float4 clipPos)
{
    return (clipPos.z > clipPos.w
            || clipPos.x < -clipPos.w
            || clipPos.x > clipPos.w
            || clipPos.y < -clipPos.w
            || clipPos.y > clipPos.w) ? 0 : 1;
}

uint IsVisibleAfterOcclusionCulling(float clipMinX, float clipMaxX, float clipMinY, float clipMaxY, float clipMinZ)
{
    float2 minXY = float2(clipMinX, clipMinY) * 0.5 + 0.5;
    float2 maxXY = float2(clipMaxX, clipMaxY) * 0.5 + 0.5;

    int2 size = (maxXY - minXY) * _HiZTextureSize.xy;
    float mip = ceil(log2(max(size.x, size.y)));
    mip = clamp(mip, 0, 10);

    float level_lower = max(mip - 1, 0);
    float2 scale = exp2(-level_lower);
    float2 a = floor(minXY * scale);
    float2 b = ceil(maxXY * scale);
    float2 dims = b - a;

    if (dims.x <= 2 && dims.y <= 2)
    {
        mip = level_lower;
    }

    const int xSamples = 8;
    const int ySamples = 25;
    const float widthSS = (maxXY.x - minXY.x);
    const float heightSS = (maxXY.y - minXY.y);
    const float stepX = widthSS / xSamples;
    const float stepY = heightSS / ySamples;

    float HIZdepth = 1;
    float yPos = minXY.y;
    for (int y = 0; y < ySamples; ++y)
    {
        float xPos = minXY.x;
        for (int x = 0; x < xSamples; ++x)
        {
            float2 nCoords0 = float2(xPos, yPos);
            HIZdepth = min(HIZdepth, _HiZMap.SampleLevel(sampler_HiZMap, nCoords0, mip).r);
            xPos += stepX;
        }
        yPos += stepY;
    }

    return (1.0 - clipMinZ) > HIZdepth - 0.000015;
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{   
    int2 currentIndex = _GridStartIndex + id.xy;//Index in the Grid

    float2 positionXZ = currentIndex * _Spacing;//Transform to World position

    float2 randomOffset = float2(random(currentIndex.x * 5542 + currentIndex.y), random(currentIndex.y * 9824 + currentIndex.x));
	positionXZ += (randomOffset * 2 - 1) * _Spacing;//Adding a small offset to it
	
    float2 uv = (positionXZ - _CenterPos) / (_TextureUpdateThreshold + _DrawDistance); uv = uv * 0.5 + 0.5;
    
    float2 heightMap = _GrassHeightMapRT.SampleLevel(linearClampSampler, uv, 0).rg;//Sampling the HeightMap Texture (Red Channel: Height, Green Channel: Area where grass should be spawned)
    
    float maskValue = _GrassMaskMapRT.SampleLevel(linearClampSampler, uv, 0).r;//Sampling the Mask Texture
    //Since the mask map describes the density and not just areas where the grass should be or not
    //We calculate a random number and test if it's bigger than the mask value
    //if the mask value = 1, the random value will never reach 1 so the result is FALSE
    //if the mask value = 0, the random value is always >= 0, so the result is TRUE
    //if the mask value = 0.5, the result depends on the random value calculated
    bool inMask = saturate(random(currentIndex.x * 9421 + currentIndex.y) - 0.001) >= maskValue;
    
    if (heightMap.g == 1 && inMask)
    {
        float positionY = Remap(heightMap.r, float2(0, 1), float2(_BoundsMin.y, _BoundsMax.y));//Reconstruct the Y position from the Height Map
	
        float3 positionWS = float3(positionXZ.x, positionY, positionXZ.y);

        // Smooth density falloff using a stable random threshold per cell.
        // As the camera moves away, fewer positions pass this probability test
        // which avoids popping or flickering at long distances.
        float distanceFromCamera = length(_CameraPosition - positionWS);

        // 1 at the camera and 0 at the draw distance
        float falloff = saturate(1.0 - distanceFromCamera / _DrawDistance);
        falloff = pow(falloff, _DensityFalloffExponent);
        float densityFactor = falloff * _FullDensityDistance;

        // Stable random value based on cell coordinates
        float randVal = random(currentIndex.x + currentIndex.y * 7954);
        bool insideDensityLevel = randVal <= densityFactor;

        if (insideDensityLevel)
        {
            float3 minPos = positionWS + float3(0, 0.8, 0) - float3(0.75 * 0.5, 0.8, 0.75 * 0.5);
            float3 maxPos = positionWS + float3(0, 0.8, 0) + float3(0.75 * 0.5, 0.8, 0.75 * 0.5);

            float4 boxCorners[8];
            boxCorners[0] = float4(minPos.x, minPos.y, minPos.z, 1.0);
            boxCorners[1] = float4(minPos.x, minPos.y, maxPos.z, 1.0);
            boxCorners[2] = float4(minPos.x, maxPos.y, minPos.z, 1.0);
            boxCorners[3] = float4(minPos.x, maxPos.y, maxPos.z, 1.0);
            boxCorners[4] = float4(maxPos.x, minPos.y, minPos.z, 1.0);
            boxCorners[5] = float4(maxPos.x, minPos.y, maxPos.z, 1.0);
            boxCorners[6] = float4(maxPos.x, maxPos.y, minPos.z, 1.0);
            boxCorners[7] = float4(maxPos.x, maxPos.y, maxPos.z, 1.0);

            float4 clipPos = mul(_VPMatrix, boxCorners[0]);
            uint isInFrustum = IsVisibleAfterFrustumCulling(clipPos);

            clipPos.xyz /= clipPos.w;
            float clipMinX = clipPos.x;
            float clipMaxX = clipPos.x;
            float clipMinY = clipPos.y;
            float clipMaxY = clipPos.y;
            float clipMinZ = clipPos.z;

            [unroll]
            for (int i = 1; i < 8; i++)
            {
                clipPos = mul(_VPMatrix, boxCorners[i]);
                isInFrustum = saturate(isInFrustum + IsVisibleAfterFrustumCulling(clipPos));
                clipPos.xyz /= clipPos.w;
                clipMinX = min(clipPos.x, clipMinX);
                clipMaxX = max(clipPos.x, clipMaxX);
                clipMinY = min(clipPos.y, clipMinY);
                clipMaxY = max(clipPos.y, clipMaxY);
                clipMinZ = min(clipPos.z, clipMinZ);
            }

            uint isVisible = isInFrustum;
            isVisible *= IsVisibleAfterOcclusionCulling(clipMinX, clipMaxX, clipMinY, clipMaxY, clipMinZ);

            if (isVisible > 0 && distanceFromCamera <= _DrawDistance)
            {
                _GrassPositions.Append(float4(positionWS, distanceFromCamera));
            }
        }
    }
}
